#version 450
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer InputBuffer {
    uint inputData[];
};

layout(std430, binding = 1) writeonly buffer OutputBuffer {
    uint outputData[];
};

// AES Extended Layout (works for both 128 and 256)
// batchSize@0, numRounds@4, padding[2]@8-16, RoundKey[60]@16-256, IV[4]@256-272, SBox[256]@272
layout(std430, binding = 2) readonly buffer Params {
    uint batchSize;
    uint numRounds;     // 10 for AES-128, 14 for AES-256
    uint padding[2];
    uint RoundKey[60];
    uint IV[4];
    uint SBox[256];
} params;

#define GET_B0(x) ((x) & 0xFF)
#define GET_B1(x) ((x >> 8) & 0xFF)
#define GET_B2(x) ((x >> 16) & 0xFF)
#define GET_B3(x) ((x >> 24) & 0xFF)

uint SubWord(uint w) {
    return params.SBox[GET_B0(w)] |
           (params.SBox[GET_B1(w)] << 8) |
           (params.SBox[GET_B2(w)] << 16) |
           (params.SBox[GET_B3(w)] << 24);
}

#define xtime(x) ((((x)<<1) ^ ((((x)>>7) & 1) * 0x1b)) & 0xFF)

uint MixColumn(uint c) {
   uint b0 = GET_B0(c);
   uint b1 = GET_B1(c);
   uint b2 = GET_B2(c);
   uint b3 = GET_B3(c);
   
   uint d0 = xtime(b0) ^ (xtime(b1) ^ b1) ^ b2 ^ b3;
   uint d1 = b0 ^ xtime(b1) ^ (xtime(b2) ^ b2) ^ b3;
   uint d2 = b0 ^ b1 ^ xtime(b2) ^ (xtime(b3) ^ b3);
   uint d3 = (xtime(b0) ^ b0) ^ b1 ^ b2 ^ xtime(b3);
   
   return d0 | (d1<<8) | (d2<<16) | (d3<<24);
}

void main() {
    uint gID = gl_GlobalInvocationID.x;
    if (gID >= params.batchSize) return;

    // Load IV + Counter
    uint b0 = params.IV[0];
    uint b1 = params.IV[1];
    uint b2 = params.IV[2];
    uint b3 = params.IV[3];
    
    // AES-CTR: Big-endian counter increment
    #define BSWAP(x) (((x) >> 24) | (((x) & 0x00FF0000u) >> 8) | (((x) & 0x0000FF00u) << 8) | ((x) << 24))
    uint be_b3 = BSWAP(b3);
    uint old_be = be_b3;
    be_b3 += gID;
    b3 = BSWAP(be_b3);
    if (be_b3 < old_be) {
        uint be_b2 = BSWAP(b2);
        be_b2++;
        b2 = BSWAP(be_b2);
    }
    
    // Initial AddRoundKey
    uint s0 = b0 ^ params.RoundKey[0];
    uint s1 = b1 ^ params.RoundKey[1];
    uint s2 = b2 ^ params.RoundKey[2];
    uint s3 = b3 ^ params.RoundKey[3];
    
    // DYNAMIC rounds: uses params.numRounds
    uint nr = params.numRounds;
    for (uint r = 1; r < nr; r++) {
        uint t0 = SubWord(s0);
        uint t1 = SubWord(s1);
        uint t2 = SubWord(s2);
        uint t3 = SubWord(s3);
        
        uint c0 = (t0 & 0xFF) | (t1 & 0xFF00) | (t2 & 0xFF0000) | (t3 & 0xFF000000);
        uint c1 = (t1 & 0xFF) | (t2 & 0xFF00) | (t3 & 0xFF0000) | (t0 & 0xFF000000);
        uint c2 = (t2 & 0xFF) | (t3 & 0xFF00) | (t0 & 0xFF0000) | (t1 & 0xFF000000);
        uint c3 = (t3 & 0xFF) | (t0 & 0xFF00) | (t1 & 0xFF0000) | (t2 & 0xFF000000);
        
        s0 = MixColumn(c0) ^ params.RoundKey[4*r + 0];
        s1 = MixColumn(c1) ^ params.RoundKey[4*r + 1];
        s2 = MixColumn(c2) ^ params.RoundKey[4*r + 2];
        s3 = MixColumn(c3) ^ params.RoundKey[4*r + 3];
    }
    
    // Final round (no MixColumns)
    uint t0 = SubWord(s0);
    uint t1 = SubWord(s1);
    uint t2 = SubWord(s2);
    uint t3 = SubWord(s3);
    
    uint c0 = (t0 & 0xFF) | (t1 & 0xFF00) | (t2 & 0xFF0000) | (t3 & 0xFF000000);
    uint c1 = (t1 & 0xFF) | (t2 & 0xFF00) | (t3 & 0xFF0000) | (t0 & 0xFF000000);
    uint c2 = (t2 & 0xFF) | (t3 & 0xFF00) | (t0 & 0xFF0000) | (t1 & 0xFF000000);
    uint c3 = (t3 & 0xFF) | (t0 & 0xFF00) | (t1 & 0xFF0000) | (t2 & 0xFF000000);
    
    // Final round key at index nr*4
    uint keyOff = nr * 4;
    s0 = c0 ^ params.RoundKey[keyOff + 0];
    s1 = c1 ^ params.RoundKey[keyOff + 1];
    s2 = c2 ^ params.RoundKey[keyOff + 2];
    s3 = c3 ^ params.RoundKey[keyOff + 3];

    // XOR with plaintext
    outputData[gID*4 + 0] = s0 ^ inputData[gID*4 + 0];
    outputData[gID*4 + 1] = s1 ^ inputData[gID*4 + 1];
    outputData[gID*4 + 2] = s2 ^ inputData[gID*4 + 2];
    outputData[gID*4 + 3] = s3 ^ inputData[gID*4 + 3];
}
